import operator
import os

import natsort
import pyo64 as pyo


class SamplePlayer(pyo.EventInstrument):
    fadein = 0.02
    fadeout = 0.03

    def __init__(self, **args) -> None:
        pyo.EventInstrument.__init__(self, **args)

        attributes_to_set_zero = ("osc_lv", "h_lv", "rm_lv", "filter_lv", "distr_lv")
        attributes_to_set_n = (
            ("rm_freq", 200),
            ("filter_freq", 200),
            ("filter_q", 1),
            ("h_transpo", -2),
            ("lv", 1),
            ("brown_noise_lv", 1),
            ("lorenz_lv", 0.85),
            ("lorenz_pitch", 0.4),
            ("lorenz_chaos", 0.5),
            ("disturbance_lv", 0.5),
            ("chenlee_pitch", 0.75),
            ("chenlee_chaos", 0.5),
        )
        attributes_to_set_n += tuple((attr, 0) for attr in attributes_to_set_zero)
        for attribute, value in attributes_to_set_n:
            try:
                getattr(self, attribute)
            except AttributeError:
                setattr(self, attribute, value)

        fade = pyo.Fader(fadein=self.fadein, fadeout=self.fadeout).play(dur=self.dur)
        fade *= self.lv

        if self.path is not None:
            self.osc = SamplePlayer.make_osc(self.path, mul=fade).play(dur=self.dur)
            self.original = SamplePlayer.make_osc(
                self.path, mul=fade * self.osc_lv
            ).out(self.channel, dur=self.dur)
            self.h = pyo.Harmonizer(
                self.osc, transpo=self.h_transpo, mul=self.h_lv
            ).out(self.channel)
            self.filtered = pyo.Reson(
                self.osc, freq=self.filter_freq, q=self.filter_q, mul=self.filter_lv
            ).out(self.channel)
            self.distr = pyo.Disto(self.osc, mul=self.distr_lv).out(self.channel)
            self.rm = (pyo.Sine(self.rm_freq) * self.osc * self.rm_lv).out(self.channel)

        # ambient noise
        noise_dur = self.dur + self.fadein + self.fadeout
        self.noise_fader = pyo.Linseg(
            [(0, self.noise_lv[0]), (self.dur, self.noise_lv[1])]
        ).play(dur=noise_dur)

        self.lorenz = pyo.Lorenz(
            pitch=self.lorenz_pitch, chaos=self.lorenz_chaos, mul=self.lorenz_lv
        ).play(dur=noise_dur)

        self.brown = pyo.BrownNoise(mul=self.brown_noise_lv).play(dur=noise_dur)

        self.ambient_noise = ((self.brown + self.lorenz) * self.noise_fader * fade).out(
            self.channel
        )

        # additional noise
        # similar to sounds generated by natural radio, I love it!
        self.disturbance = pyo.ChenLee(
            pitch=self.chenlee_pitch,
            chaos=self.chenlee_chaos,
            mul=fade * self.disturbance_lv,
        ).out(self.channel)
        # basically more interesting noise generator, could be mixed to brown noise
        # 'dirty sine wave': I could imagine combining this with Yen and finding
        # the correct asked pitch. or implenting a new Rossler yourself
        # where you can control the pitch.
        # self.mys = pyo.Sine(1).play()
        # self.disturbance = pyo.Rossler(pitch=0.4, chaos=self.mys, mul=fade).out(
        #     self.channel
        # )

    @staticmethod
    def make_osc(path: str, mul=1) -> pyo.Osc:
        soundfile = pyo.SndTable(path)
        return pyo.Osc(soundfile, freq=soundfile.getRate(), interp=4, mul=mul)


class BrokenRadio(object):
    # aka the time machine

    def __init__(self, sources: tuple, channels: int) -> None:
        self.sources = sources
        self.channels = channels
        self.server = pyo.Server(sr=96000, audio="offline", nchnls=channels).boot()
        self.path_per_source = BrokenRadio.detect_files(self.sources)
        self.data_per_source = BrokenRadio.detect_data_per_source(self.path_per_source)

    @staticmethod
    def detect_files(sources: tuple) -> tuple:
        files_per_source = []
        for path in sources:
            all_files = natsort.natsorted(os.listdir(path))
            soundfiles = filter(lambda f: f.endswith("wav"), all_files)
            files_per_source.append(tuple(path + f for f in soundfiles))
        return tuple(files_per_source)

    @staticmethod
    def detect_data_per_source(path_per_source: tuple) -> tuple:
        return tuple(
            tuple(pyo.sndinfo(path) for path in source) for source in path_per_source
        )

    @staticmethod
    def convert_sample_names2pyo_objects(path: str, files: tuple) -> tuple:
        return tuple(pyo.SndTable(path + f) for f in files)

    def __call__(self, name: str, duration: 10) -> None:
        self.server.recordOptions(dur=duration, filename=name, sampletype=4)

        import random

        ig1 = operator.itemgetter(1)
        duration_per_sample = tuple(ig1(info) for info in self.data_per_source[0])

        duration_per_event = tuple(dps - 1 for dps in duration_per_sample)
        channel_per_event = tuple(1 for i in duration_per_event)

        noise_lv_per_event = tuple(random.uniform(0.2, 0.4) for i in duration_per_event)
        noise_lv_per_event = tuple(
            (a, b) for a, b in zip((0,) + noise_lv_per_event, noise_lv_per_event)
        )

        event_lv = tuple(1 for i in duration_per_event)
        osc_lv_per_event = tuple(random.uniform(0, 0) for i in duration_per_event)
        h_lv_per_event = tuple(random.uniform(0, 0) for i in duration_per_event)
        filter_lv_per_event = tuple(random.uniform(0.6, 2) for i in duration_per_event)
        distr_lv_per_event = tuple(random.uniform(0, 0) for i in duration_per_event)
        rm_lv_per_event = tuple(random.uniform(0.05, 0.15) for i in duration_per_event)

        filter_freq_per_event = tuple(
            random.uniform(150.0, 250.0) for i in duration_per_event
        )
        filter_q_per_event = tuple(random.uniform(1.0, 2.0) for i in duration_per_event)

        rm_freq_per_event = tuple(
            random.uniform(1500.0, 2000.0) for i in duration_per_event
        )

        transpo_per_event = tuple(random.uniform(-7, 7) for i in duration_per_event)

        disturbance_lv_per_event = tuple(
            random.uniform(0.5, 0.75) for i in duration_per_event
        )

        chenlee_chaos_per_event = tuple(
            random.uniform(0.5, 1) for i in duration_per_event
        )
        chenlee_pitch_per_event = tuple(
            random.uniform(0.5, 0.75) for i in duration_per_event
        )

        lorenz_chaos_per_event = tuple(
            random.uniform(0.5, 0.7) for i in duration_per_event
        )
        lorenz_pitch_per_event = tuple(
            random.uniform(0.5, 0.6) for i in duration_per_event
        )

        e = pyo.Events(
            instr=SamplePlayer,
            path=self.path_per_source[0],
            dur=duration_per_event,
            channel=channel_per_event,
            lv=event_lv,
            noise_lv=noise_lv_per_event,
            osc_lv=osc_lv_per_event,
            h_lv=h_lv_per_event,
            filter_lv=filter_lv_per_event,
            distr_lv=distr_lv_per_event,
            rm_lv=rm_lv_per_event,
            filter_freq=filter_freq_per_event,
            filter_q=filter_q_per_event,
            rm_freq=rm_freq_per_event,
            h_transpo=transpo_per_event,
            disturbance_lv=disturbance_lv_per_event,
            chenlee_chaos=chenlee_chaos_per_event,
            chenlee_pitch=chenlee_pitch_per_event,
            lorenz_chaos=lorenz_chaos_per_event,
            lorenz_pitch=lorenz_pitch_per_event,
        )
        e.play()

        self.server.start()


if __name__ == "__main__":
    # my_radio = BrokenRadio(["weather_forecast/deutsch0/"], 1)
    # my_radio = BrokenRadio(["weather_forecast/english3/"], 1)
    my_radio = BrokenRadio(["weather_forecast/deutsch0/"], 1)
    my_radio("hi.wav", 20)

    # my_radio = BrokenRadio(["fisher/0/"], 1)
    # 32 seconds reaching introduction of fisher
    # my_radio("fisher_introduction.wav", 32.88)

    """
    als n채chstes tun verschiedene kleine methoden schreiben, die parameter ausf체llen
    namentlich
        * FADE_IN / FADE_OUT -> erst mehr Abst채nde zwischen den Sprachsamples, Pausen
        mit Rauschen und Stille bis am Ende normaleAbst채nde, INPUT:
        dauer des fades in Sekunden
        * verschiedene Standard-Funktionen, die Radiosound erzeugen, entweder mit einem
        SamplePool oder mit mehreren
    """
